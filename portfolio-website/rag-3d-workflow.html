<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>3D RAG Architecture Cinematic Flow</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&amp;family=Rajdhani:wght@300;500;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#00E5FF",secondary: "#7B61FF",accent: "#FF2E63",success: "#00FF94",warning: "#FFD700","background-light": "#f0f4f8",
                        "background-dark": "#050510",
                        "surface-dark": "#0F1020",
                        "glass": "rgba(255, 255, 255, 0.05)"
                    },
                    fontFamily: {
                        display: ["Orbitron", "sans-serif"],
                        body: ["Rajdhani", "sans-serif"],
                    },
                    boxShadow: {
                        'neon': '0 0 10px theme("colors.primary"), 0 0 20px theme("colors.primary")',
                        'neon-secondary': '0 0 10px theme("colors.secondary"), 0 0 20px theme("colors.secondary")',
                    }
                },
            },
        };
    </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<style>
        body {
            overflow: hidden;
            margin: 0;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        .hud-overlay {
            z-index: 10;
            pointer-events: none;}
        .interactive-element {
            pointer-events: auto;
        }
        .glass-panel {
            background: rgba(15, 16, 32, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }.scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00E5FF, transparent);
            opacity: 0.5;
            animation: scan 4s linear infinite;
        }
        @keyframes scan {
            0% { top: -10%; }
            100% { top: 110%; }
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-slate-800 dark:text-slate-200 font-body transition-colors duration-300">
<div id="canvas-container"></div>
<div class="hud-overlay absolute inset-0 flex flex-col justify-between p-6 md:p-10">
<div class="flex justify-between items-start w-full">
<div class="interactive-element glass-panel p-4 rounded-xl border-l-4 border-primary shadow-lg animate-fade-in-down">
<h1 class="font-display text-2xl md:text-4xl font-bold tracking-wider text-white mb-1">
<span class="text-primary">RAG</span> ARCHITECT
                </h1>
<div class="flex items-center space-x-2 text-xs md:text-sm text-gray-400">
<span class="inline-block w-2 h-2 rounded-full bg-success animate-pulse"></span>
<span>SYSTEM ONLINE</span>
<span class="mx-2">|</span>
<span>LATENCY: 42ms</span>
</div>
</div>
<div class="interactive-element flex space-x-3">
<a href="index.html" class="glass-panel p-3 rounded-lg hover:bg-white/10 transition-all group" title="Back to Portfolio">
<span class="material-icons-round text-white group-hover:scale-110 transition-transform">arrow_back</span>
</a>
<button class="glass-panel p-3 rounded-lg hover:bg-white/10 transition-all group" onclick="resetCamera()" title="Reset View">
<span class="material-icons-round text-primary group-hover:scale-110 transition-transform">center_focus_strong</span>
</button>
<button class="glass-panel p-3 rounded-lg hover:bg-white/10 transition-all group" onclick="toggleFlow()" title="Toggle Data Flow">
<span class="material-icons-round text-secondary group-hover:scale-110 transition-transform">play_arrow</span>
</button>
<button class="glass-panel p-3 rounded-lg hover:bg-white/10 transition-all group" title="Settings">
<span class="material-icons-round text-white group-hover:rotate-90 transition-transform">settings</span>
</button>
</div>
</div>
<div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none opacity-0 transition-opacity duration-500" id="status-message">
<div class="glass-panel px-8 py-4 rounded-full border border-primary/50 bg-black/80">
<p class="font-display text-primary text-lg tracking-widest text-center">PROCESSING QUERY...</p>
</div>
</div>
<div class="flex flex-col md:flex-row justify-between items-end w-full gap-4">
<div class="interactive-element glass-panel p-4 rounded-xl max-w-sm w-full">
<h3 class="font-display text-sm text-gray-300 mb-3 border-b border-white/10 pb-2 uppercase tracking-wide">System Modules</h3>
<div class="grid grid-cols-2 gap-3 text-sm">
<div class="flex items-center space-x-2">
<span class="w-3 h-3 rounded-sm bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]"></span>
<span class="text-gray-300">User Interaction</span>
</div>
<div class="flex items-center space-x-2">
<span class="w-3 h-3 rounded-sm bg-orange-500 shadow-[0_0_8px_rgba(249,115,22,0.6)]"></span>
<span class="text-gray-300">App Backend</span>
</div>
<div class="flex items-center space-x-2">
<span class="w-3 h-3 rounded-sm bg-purple-500 shadow-[0_0_8px_rgba(168,85,247,0.6)]"></span>
<span class="text-gray-300">Vector Store</span>
</div>
<div class="flex items-center space-x-2">
<span class="w-3 h-3 rounded-sm bg-red-500 shadow-[0_0_8px_rgba(239,68,68,0.6)]"></span>
<span class="text-gray-300">RAI Check</span>
</div>
<div class="flex items-center space-x-2">
<span class="w-3 h-3 rounded-sm bg-blue-500 shadow-[0_0_8px_rgba(59,130,246,0.6)]"></span>
<span class="text-gray-300">External LLM</span>
</div>
<div class="flex items-center space-x-2">
<span class="w-3 h-3 rounded-sm bg-yellow-400 shadow-[0_0_8px_rgba(250,204,21,0.6)]"></span>
<span class="text-gray-300">Telemetry</span>
</div>
</div>
</div>
<div class="interactive-element glass-panel p-4 rounded-xl w-full md:w-96 font-mono text-xs overflow-hidden relative h-32 flex flex-col">
<div class="scan-line"></div>
<div class="flex justify-between items-center mb-2 text-primary border-b border-primary/20 pb-1">
<span>&gt;_ SYSTEM_LOGS</span>
<span class="animate-pulse">‚óè</span>
</div>
<div class="overflow-y-auto space-y-1 text-gray-400 custom-scrollbar flex-1" id="terminal-content">
<p class="text-green-400">[INFO] App Backend initialized on port 5000</p>
<p>[INFO] Connected to Vector Store</p>
<p>[INFO] External LLM Service: Ready</p>
<p class="text-yellow-400">[WARN] Telemetry buffer at 15%</p>
<p class="opacity-50">Waiting for user input...</p>
</div>
</div>
</div>
</div>
<script>
        // --- 1. SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.015);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 30);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going below grid
        // --- 2. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);
        const spotLight = new THREE.SpotLight(0x00E5FF, 2);
        spotLight.position.set(-10, 20, -5);
        spotLight.angle = 0.5;
        spotLight.penumbra = 0.5;
        scene.add(spotLight);
        const purpleLight = new THREE.PointLight(0x7B61FF, 1.5, 20);
        purpleLight.position.set(5, 5, 5);
        scene.add(purpleLight);
        // --- 3. ENVIRONMENT ---
        // Infinite Grid
        const gridHelper = new THREE.GridHelper(100, 100, 0x333333, 0x111111);
        scene.add(gridHelper);
        // Starfield
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.05});
        const starVertices = [];
        for(let i=0; i<1000; i++) {
            const x = (Math.random() - 0.5) * 100;
            const y = (Math.random() - 0.5) * 50 + 25;
            const z = (Math.random() - 0.5) * 100;
            starVertices.push(x,y,z);
        }
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        // --- 4. ARCHITECTURE NODES ---
        const nodes = [];
        const packetPath = [];
        function createNode(x, y, z, color, label, icon) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            // Glass Block
            const geometry = new THREE.BoxGeometry(3, 2, 3);
            const material = new THREE.MeshPhysicalMaterial({
                color: color,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.6, // Glass effect
                thickness: 1,
                clearcoat: 1,
                clearcoatRoughness: 0.1
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            // Wireframe Edge
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.5 }));
            // Inner Core (Glowing)
            const coreGeo = new THREE.BoxGeometry(1.5, 1, 1.5);
            const coreMat = new THREE.MeshBasicMaterial({ color: color });
            const core = new THREE.Mesh(coreGeo, coreMat);
            // Label (Using Canvas Texture applied to Top Face)
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 512;
            // Background for high contrast
            context.fillStyle = 'rgba(5, 5, 16, 0.7)'; // Dark semi-transparent background
            context.fillRect(0, 0, 512, 512);
            // Border
            context.strokeStyle = `rgba(${new THREE.Color(color).r * 255}, ${new THREE.Color(color).g * 255}, ${new THREE.Color(color).b * 255}, 0.8)`;
            context.lineWidth = 15;
            context.strokeRect(10, 10, 492, 492);
            // Icon (Emoji)
            context.font = '200px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif'; 
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(icon, 256, 200);
            // Label Text (High Contrast)
            context.font = 'bold 50px "Orbitron", sans-serif'; 
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.shadowColor = "black";
            context.shadowBlur = 10;
            context.lineWidth = 4;
            context.strokeText(label, 256, 380); // Outline for better contrast
            context.fillText(label, 256, 380);
            const texture = new THREE.CanvasTexture(canvas);
            // Create label mesh on Top Face
            const labelGeo = new THREE.PlaneGeometry(2.8, 2.8);
            const labelMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
            const labelMesh = new THREE.Mesh(labelGeo, labelMat);
            labelMesh.rotation.x = -Math.PI / 2; // Lie flat
            labelMesh.position.y = 1.01; // Slightly above top face (y=1)
            group.add(cube);
            group.add(line);
            group.add(core);
            group.add(labelMesh);
            scene.add(group);
            nodes.push({ mesh: group, label: labelMesh, initialY: y });
            return group;
        }
        // Define Nodes based on Diagram - UPDATED LABELS
        const userNode = createNode(-10, 2, 10, 0x4ade80, "User Interaction", "üë§"); // Green
        const flaskNode = createNode(-5, 2, 5, 0xf97316, "App Backend", "‚öôÔ∏è"); // Orange
        const raiNode = createNode(0, 2, 5, 0xef4444, "RAI Check", "üõ°Ô∏è"); // Red
        const langchainNode = createNode(5, 2, 0, 0x3b82f6, "LangChain", "üîó"); // Blue
        const vectorNode = createNode(5, 0, 5, 0xa855f7, "Vector Store", "üíæ"); // Purple
        const llmNode = createNode(10, 4, -5, 0x3b82f6, "External LLM", "ü§ñ"); // Blue
        const telemetryNode = createNode(-8, 4, -5, 0xfacc15, "Telemetry", "üìä"); // Yellow
        // Create Connections (Tubes)
        function createConnection(startMesh, endMesh, isReturn = false) {
            const start = startMesh.position.clone();
            const end = endMesh.position.clone();
            // Create a curved path
            const mid = start.clone().lerp(end, 0.5);
            mid.y += 2; // Arc height
            // For return paths, reverse the curve direction
            const curve = isReturn 
                ? new THREE.QuadraticBezierCurve3(end, mid, start)
                : new THREE.QuadraticBezierCurve3(start, mid, end);
            const points = curve.getPoints(20);
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: isReturn ? 0x00E5FF : 0x555555, 
                opacity: isReturn ? 0.5 : 0.3, 
                transparent: true 
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            return curve;
        }
        // Forward paths (query flow)
        const path1 = createConnection(userNode, flaskNode, false);
        const path2 = createConnection(flaskNode, raiNode, false);
        const path3 = createConnection(raiNode, langchainNode, false);
        const path4 = createConnection(langchainNode, vectorNode, false);
        const path5 = createConnection(langchainNode, llmNode, false); // Retrieval to Generation
        const path6 = createConnection(flaskNode, telemetryNode, false);
        
        // Return paths (response flow) - reversed connections
        const returnPath1 = createConnection(llmNode, langchainNode, true); // LLM response back
        const returnPath2 = createConnection(vectorNode, langchainNode, true); // Retrieved docs back
        const returnPath3 = createConnection(langchainNode, raiNode, true); // Processed context back
        const returnPath4 = createConnection(raiNode, flaskNode, true); // Validated response back
        const returnPath5 = createConnection(flaskNode, userNode, true); // Final response to user
        
        // Store active paths for animation
        const activePaths = [path1, path2, path3, path4, path5, path6, returnPath1, returnPath2, returnPath3, returnPath4, returnPath5];
        // --- 5. ANIMATION & PARTICLES ---
        const packets = [];
        function spawnPacket(curve, color, isReturn = false) {
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const sphere = new THREE.Mesh(geometry, material);
            // Make return packets slightly different (glow effect)
            if (isReturn) {
                const glowGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                sphere.add(glow);
            }
            scene.add(sphere);
            packets.push({
                mesh: sphere,
                curve: curve,
                progress: 0,
                speed: 0.01 + Math.random() * 0.01,
                isReturn: isReturn
            });
        }
        // Spawn initial packets (forward flow)
        setInterval(() => {
            spawnPacket(path1, 0x4ade80, false); // User query
        }, 2000);
        setInterval(() => {
            spawnPacket(path6, 0xfacc15, false); // Telemetry logs
        }, 1500);
        // --- 6. LOGGING SYSTEM MOCKUP ---
        const terminal = document.getElementById('terminal-content');
        const logs = [
            "Query received from client ID: 8X92",
            "RAI Safety Check: PASSED",
            "Embedding query vector...",
            "Searching Vector Store index",
            "Retrieved 3 relevant documents",
            "Context window constructed",
            "Sending payload to External LLM",
            "Response generated (Tokens: 450)",
            "Telemetry logged to DB"
        ];
        function addLog() {
            const log = logs[Math.floor(Math.random() * logs.length)];
            const p = document.createElement('p');
            p.className = "text-xs font-mono text-primary animate-pulse";
            p.innerText = `> ${log}`;
            terminal.appendChild(p);
            terminal.scrollTop = terminal.scrollHeight;
            // Limit log size
            if(terminal.children.length > 10) {
                terminal.removeChild(terminal.children[0]);
            }
        }
        setInterval(addLog, 2500);
        // --- 7. RENDER LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();
            // Animate Nodes (Float)
            nodes.forEach((node, i) => {
                node.mesh.position.y = node.initialY + Math.sin(time + i) * 0.2;
                // Labels are attached to mesh now, no lookAt needed
            });
            // Animate Packets
            for (let i = packets.length - 1; i >= 0; i--) {
                const packet = packets[i];
                packet.progress += packet.speed;
                if (packet.progress >= 1) {
                    scene.remove(packet.mesh);
                    packets.splice(i, 1);
                    // Forward flow triggers
                    if (packet.curve === path1) spawnPacket(path2, 0xef4444, false); // Flask to RAI
                    if (packet.curve === path2) spawnPacket(path3, 0x3b82f6, false); // RAI to LangChain
                    if (packet.curve === path3) {
                        spawnPacket(path4, 0xa855f7, false); // To Vector Store
                        spawnPacket(path5, 0x3b82f6, false); // To LLM
                    }
                    // Return flow triggers (response coming back)
                    if (packet.curve === path4) {
                        // Vector Store returns retrieved docs
                        spawnPacket(returnPath2, 0x00E5FF, true); // Cyan for return
                    }
                    if (packet.curve === path5) {
                        // LLM returns generated response
                        spawnPacket(returnPath1, 0x00E5FF, true); // Cyan for return
                    }
                    if (packet.curve === returnPath1 || packet.curve === returnPath2) {
                        // LangChain processes and returns
                        spawnPacket(returnPath3, 0x00E5FF, true);
                    }
                    if (packet.curve === returnPath3) {
                        // RAI validates and returns
                        spawnPacket(returnPath4, 0x00E5FF, true);
                    }
                    if (packet.curve === returnPath4) {
                        // Flask sends final response to user
                        spawnPacket(returnPath5, 0x00FF94, true); // Bright green for final response
                    }
                } else {
                    const point = packet.curve.getPoint(packet.progress);
                    packet.mesh.position.copy(point);
                    // Animate return packet glow
                    if (packet.isReturn && packet.mesh.children.length > 0) {
                        packet.mesh.children[0].scale.setScalar(1 + Math.sin(time * 5) * 0.2);
                    }
                }
            }
            // Rotate Stars slowly
            stars.rotation.y = time * 0.05;
            renderer.render(scene, camera);
        }
        animate();
        // --- 8. INTERACTION FUNCTIONS ---
        window.resetCamera = () => {
            gsap.to(camera.position, {
                x: 20, y: 15, z: 30,
                duration: 1.5,
                ease: "power2.inOut"
            });
            gsap.to(controls.target, {
                x: 0, y: 0, z: 0,
                duration: 1.5,
                ease: "power2.inOut"
            });
        };
        window.toggleFlow = () => {
            const status = document.getElementById('status-message');
            status.style.opacity = '1';
            // Burst of packets
            for(let i=0; i<5; i++) {
                setTimeout(() => spawnPacket(path1, 0x00E5FF), i * 200);
            }
            setTimeout(() => {
                status.style.opacity = '0';
            }, 3000);
        };
        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body></html>